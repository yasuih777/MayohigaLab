[
  {
    "objectID": "qmds/posts.html",
    "href": "qmds/posts.html",
    "title": "記事",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n不均衡データに対する二値分類評価指標の挙動\n\n\n2 min\n\n\n\nPython\n\n\nExperiment\n\n\n\n\n\n\n\n\n\n\n2025-02-09\n\n\n\n\n\n\n\n\n\n\n\nウイルス感染症の数理シミュレーション（基礎）\n\n\n5 min\n\n\n\nJulia\n\n\nSimulation\n\n\n\n\n\n\n\n\n\n\n2025-02-09\n\n\n\n\n\n\n\n\n\n\n\nQuartoでWebページを作る際のDocker構成について\n\n\n2 min\n\n\n\nQuarto\n\n\nDocker\n\n\nR\n\n\nPython\n\n\nJulia\n\n\n\n\n\n\n\n\n\n\n2025-02-02\n\n\n\n\n\n\n\n\nNo matching items\n\nReuseCC BY 4.0"
  },
  {
    "objectID": "qmds/index.html",
    "href": "qmds/index.html",
    "title": "ホーム",
    "section": "",
    "text": "管理者が興味があることを書いていきます。\n\n統計理論の検証\n数値シミュレーション\n学習の忘備録\n\nなどなど"
  },
  {
    "objectID": "qmds/index.html#ブログ内のコンテンツ",
    "href": "qmds/index.html#ブログ内のコンテンツ",
    "title": "ホーム",
    "section": "ブログ内のコンテンツ",
    "text": "ブログ内のコンテンツ\n本サイトにおける各エントリの文章や画像などのコンテンツはクリエイティブ・コモンズ・ライセンスを適応します。"
  },
  {
    "objectID": "qmds/index.html#ブログ内サンプルコードのライセンス",
    "href": "qmds/index.html#ブログ内サンプルコードのライセンス",
    "title": "ホーム",
    "section": "ブログ内サンプルコードのライセンス",
    "text": "ブログ内サンプルコードのライセンス\nブログ内で書いているコードに関しては例外的にMIT Licenceを適応します。\n\n\n\n\n\n\nMIT License\n\n\n\n\n\nCopyright 2025\n以下に定める条件に従い、本ソフトウェアおよび関連文書のファイル（以下「ソフトウェア」）の複製を取得するすべての人に対し、ソフトウェアを無制限に扱うことを無償で許可します。これには、ソフトウェアの複製を使用、複写、変更、結合、掲載、頒布、サブライセンス、および/または販売する権利、およびソフトウェアを提供する相手に同じことを許可する権利も無制限に含まれます。\n上記の著作権表示および本許諾表示を、ソフトウェアのすべての複製または重要な部分に記載するものとします。\nソフトウェアは「現状のまま」で、明示であるか暗黙であるかを問わず、何らの保証もなく提供されます。ここでいう保証とは、商品性、特定の目的への適合性、および権利非侵害についての保証も含みますが、それに限定されるものではありません。 作者または著作権者は、契約行為、不法行為、またはそれ以外であろうと、ソフトウェアに起因または関連し、あるいはソフトウェアの使用またはその他の扱いによって生じる一切の請求、損害、その他の義務について何らの責任も負わないものとします。"
  },
  {
    "objectID": "qmds/posts/20250209_virus_simulation_1/index.html",
    "href": "qmds/posts/20250209_virus_simulation_1/index.html",
    "title": "ウイルス感染症の数理シミュレーション（基礎）",
    "section": "",
    "text": "ウイルス感染の疫学を正しく理解することは、適切な対応や施策を打つうえでとても重要である。アプローチとして、ウイルス動態を数式で表現し、そのシミュレーションやパラメータ推定を行うことがとても有効である。\nそこで、ウイルス感染の数理シミュレーションの基礎を扱い、どのような技術が使われているのか確認する。\n\n指数方程式\nまず、ウイルスと細胞間のシンプルな作用に関するモデルを仮定する。\n\n\n\n\n\n\n\nG\n\n\n\nV\n\nVirus\n\n\n\nVout\n\n\n\n\nV-&gt;Vout\n\n\nremoval\n\n\n\nconVTC2IC\n\n\n\n\nV-&gt;conVTC2IC\n\n\n\n\nTC\n\nTarget cells\n\n\n\nTC-&gt;conVTC2IC\n\n\n\n\nIC\n\nInfected cells\n\n\n\nIC-&gt;V\n\n\nproduction\n\n\n\nconVTC2IC-&gt;IC\n\n\ninfection\n\n\n\n\n\n\n\n\nウイルス感染のごく初期では体内のウイルス量が指数的に増加することが明らかになっている。時刻\\(t\\)におけるウイルス量を\\(V(t)\\)としたとき、Equation 1 の微分方程式で記述でき、一般解も得られる。\nまた、初期ウイルス量が2倍になるまでの時間を倍化時間\\(t_{D}=\\log(2 / G)\\)という。\n\n\\(V(t)\\): ウイルス量\n\\(G\\): 正の定数で、ウイルスの増加率を表す\n\n\\[\n\\begin{align}\n&\\frac{\\partial V(t)}{\\partial t} = G V(t) \\\\\n&V(t) = V(0) \\exp(G t)\n\\end{align}\n\\tag{1}\\]\n一方、ウイルス感染が十分に広がった後に抗ウイルス剤などでウイルスの増加を協力に抑制できたとき、ウイルスが死滅していくことでウイルス量が指数的に減少することが明らかになっている。このとき、Equation 2 の微分方程式で記述でき、同様に一般解も得られる。\nまた、初期ウイルス量が1/2倍になるまでの時間を半減期\\(t_{H}=\\log(2 / D)\\)という。\n\n\\(V(t)\\): ウイルス量\n\\(D\\): 正の定数で、ウイルスの減少率を表す\n\n\\[\n\\begin{align}\n&\\frac{\\partial V(t)}{\\partial t} = -D V(t) \\\\\n&V(t) = V(0) \\exp(-D t)\n\\end{align}\n\\tag{2}\\]\nまた、放出されたウイルスが排除されるまでの平均滞在時間を平均寿命と定義し、方程式 Equation 3 で求められる。\n\\[\n\\int^{\\infty}_{0} s \\exp(-D s) ds = \\frac{1}{D} \\\\\n\\tag{3}\\]\nウイルス量の増加(Equation 1 )および減少(Equation 2 )の指数方程式を描画すると、\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数方程式\n\n\n\n\n\nこれらの指数方程式を利用することで、線形回帰によってウイルス動態のパラメータ推定を行うことができる。Equation 2 を変形すると以下のようになり、\\(-D\\)が回帰係数、\\(V(0)\\)が切片に該当する。\n\\[\n\\log V(t) = \\log V(0) - D t\n\\]\n\n\nロジスティック方程式\n指数方程式ではウイルスと細胞間のシンプルな作用について考えた、ここでは細胞数に上限があり、ウイルスの増殖に制限がかかっているモデルを仮定する。実際は細胞が無限に存在することはないので、こちらの方がリアルな動態を仮定できる。\n\n\n\n\n\n\n\nG\n\n\ncluster_cell\n\nCells size Limited\n\n\n\nV\n\nVirus\n\n\n\nVout\n\n\n\n\nV-&gt;Vout\n\n\nremoval\n\n\n\nconVTC2IC\n\n\n\n\nV-&gt;conVTC2IC\n\n\n\n\nTC\n\nTarget cells\n\n\n\nTC-&gt;conVTC2IC\n\n\n\n\nIC\n\nInfected cells\n\n\n\nIC-&gt;V\n\n\nproduction\n\n\n\nconVTC2IC-&gt;IC\n\n\ninfection\n\n\n\n\n\n\n\n\nウイルスの増殖が進むにつれて標的となる細胞が減ってくるため、ウイルスの増殖速度が低下する。これを微分方程式で表現すると Equation 4 となり、ロジスティック方程式と呼ぶ。これも一般解が得られる。\n\n\n\n\n\n\nNote\n\n\n\n一般解を整理すると、ロジスティック関数が得られる。 \\[\nf(x) = \\frac{1}{1 + \\exp(-x)}\n\\]\n\n\n\n\\(V(t)\\): ウイルス量\n\\(G\\): 正の定数で、内的自然増加率を表す\n\\(K_{V}\\): 正の定数で、環境収容力を表す\n\n環境が維持できる最大ウイルス量\n\n\n\\[\n\\begin{align}\n&\\frac{\\partial V(t)}{\\partial t} = G V(t) \\left(1 - \\frac{V(t)}{K_{V}} \\right) \\\\\n&V(t) = \\frac{V(0) K_{V} \\exp(G t)}{K_{V} - V(0) + V(0) \\exp(G t)}\n\\end{align}\n\\tag{4}\\]\nウイルス量の動態 Equation 4 を描画すると、いずれの初期値でも環境収容力\\(K_{V}\\)に収束していく。\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: ロジスティック方程式: K_V=5.0 * 10^6\n\n\n\n\n\n\n\n線形微分方程式\nロジスティック方程式によって細胞増殖に制限がかかるケースを考えた。今度は、別の視点として免疫系でウイルスが排除される、ウイルスが自然に死亡するなど、感染以外でウイルス量が増減するモデルを仮定する。\n\n\n\n\n\n\n\nG\n\n\n\nV\n\nVirus(V)\n\n\n\nVout\n\n\n\n\nV-&gt;Vout\n\n\nremoval(c)\n\n\n\nconVTC2IC\n\n\n\n\nV-&gt;conVTC2IC\n\n\n\n\nTC\n\nTarget cells(T)\n\n\n\nTC-&gt;conVTC2IC\n\n\n\n\nIC\n\nInfected cells(I)\n\n\n\nIC-&gt;V\n\n\nproduction rate(p)\n\n\n\nICout\n\n\n\n\nIC-&gt;ICout\n\n\nmortality rate(delta)\n\n\n\nconVTC2IC-&gt;IC\n\n\ninfection(beta)\n\n\n\n\n\n\n\n\n時間経過による動態が複数でありかつそれらが相互作用を持つ場合、モデルは連立微分方程式によって記述される。Equation 5 はウイルス量\\(V(t)\\)と感染細胞数\\(V(t)\\)のについて記述した方程式であり、特に線形結合のみなので線形微分方程式と呼ぶ。\n\n\\(I(t)\\): 感染細胞数\n\\(V(t)\\): ウイルス量\n\\(T(0)\\): 標的細胞数(\\(t\\)に寄らず、初期値を維持すると仮定)\n\\(p\\): ウイルスの生産速度\n\\(\\delta\\): 免疫による感染細胞の排除速度\n\\(\\beta\\): ウイルスの感染率\n\\(c\\): 自然応答によるウイルスの排除速度\n\n\\[\n\\begin{align}\n&\\frac{\\partial I(t)}{\\partial t} = \\beta T(0) V(t) - \\delta I(t) \\\\\n&\\frac{\\partial V(t)}{\\partial t} = p I(t) - c V(t)\n\\end{align}\n\\tag{5}\\]\nこれらパラメータにより以下の重要な指標が定義できる。\n\n平均的なウイルス産生期間: \\(1 / \\delta\\)\n1つの感染細胞が生涯に生産するウイルス量: \\(p / \\delta\\)\n\nウイルスバーストサイズと呼ぶ。薬剤効果の定量比較などに用いられる\n\nウイルスバーストサイズによって生み出される新たな感染細胞数: \\(R_{0} = \\beta p T(0) / \\delta c\\)\n\n基本再生産数と呼ぶ。1より大きいとウイルス感染が進み、1より小さければ進行しない\n基本再生産数によって必要なウイルス阻害率を見積もることができる\n\n\nEquation 5 を行列に変換し、その固有値\\(\\theta_{1}, \\theta_{2}\\)を利用することで一般解 Equation 6 を求めることができる。\n\\[\n\\begin{align}\n&\\theta_{1} = \\frac{-(\\delta + c) + \\sqrt{(\\delta - c)^{2} + 4 \\beta p T(0)}}{2} \\\\\n&\\theta_{2} = \\frac{-(\\delta + c) - \\sqrt{(\\delta - c)^{2} + 4 \\beta p T(0)}}{2} \\\\\n&I(t) = \\frac{\\beta T(0) V(0) - (\\delta + \\theta_{2}) I(0)}{\\theta_{1} - \\theta_{2}} (e^{\\theta_{1} t} - e^{\\theta_{2} t}) + I(0) e^{\\theta_{2} t} \\\\\n&V(t) = \\frac{p I(0) - (c + \\theta_{2}) I(0)}{\\theta_{1} - \\theta_{2}} (e^{\\theta_{1} t} - e^{\\theta_{2} t}) + V(0) e^{\\theta_{2} t} \\\\\n\\end{align}\n\\tag{6}\\]\n基本再生産数\\(R0\\)が1より小さい場合\\(\\theta_{1}, \\theta_{2} &lt; 0\\)なので\\(I(t), V(t)\\)はともに正に発散する、基本再生産数\\(R0\\)が1より大きい場合\\(\\theta_{1} &gt; 0, \\theta_{2} &lt; 0\\)なので\\(I(t), V(t)\\)はともに負に発散する。\n\n\n\n\n\n\nマルサス係数\n\n\n\n加えて、固有値\\(\\theta_{1}, \\theta_{2}\\)の最大値(\\(\\theta_{1}\\))をマルサス係数\\(M\\)と呼ぶ。マルサス係数が0より大きい場合力学系は正に発散し、マルサス係数が0より小さい場合力学系は負に発散する。\n\n\nこれを描画すると、基本再生産数の条件によって感染細胞数とウイルス量の増減の向きが変わることが確認できる。\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: 線形微分方程式\n\n\n\n\n\n\n\n\n\n\n\n準定常状態近似\n\n\n\n通常、生体内においてはウイルス除去率\\(c\\)は感染細胞排除率\\(\\delta\\)よりも十分に大きい\\(c \\gg \\delta\\)と仮定する。\nさらに、準定常状態\\(0 \\simeq p I(t) - c V(t) \\Rightarrow V(t) = p I(t) / c\\)においては、\\(\\theta_{1} = p \\beta T(0) / c - \\delta\\)であり、以下のように変形できる。\n\\[\n\\frac{\\partial V(t)}{\\partial t} = \\left( \\frac{p \\beta T(0)}{c} - \\delta \\right) V(t) \\Rightarrow \\frac{\\partial V(t)}{\\partial t} = M V(t)\n\\]\nこれは、Equation 1 、Equation 2 である。このようにモデルを単純化することによって、多くの場合解釈性の高い考察を得ることができる。\n\n\n\n\n非線形微分方程式\n線形微分方程式によってウイルス量に感染細胞の相互作用を加え、動態がどうなるかを考えた。しかし、標的細胞については時間経過によらない過程を与えた単純なものであった。なので、標的細胞の相互作用も加えたより現実に近いモデルを仮定する。\n\n\n\n\n\n\n\nG\n\n\n\nV\n\nVirus(V)\n\n\n\nVout\n\n\n\n\nV-&gt;Vout\n\n\nremoval(c)\n\n\n\nconVTC2IC\n\n\n\n\nV-&gt;conVTC2IC\n\n\n\n\nTCout\n\n\n\n\nTC\n\nTarget cells(T)\n\n\n\nTCout-&gt;TC\n\n\nproduct(lambda)\n\n\n\nTC-&gt;TCout\n\n\ndead(d)\n\n\n\nTC-&gt;conVTC2IC\n\n\n\n\nIC\n\nInfected cells(I)\n\n\n\nIC-&gt;V\n\n\nproduction rate(p)\n\n\n\nICout\n\n\n\n\nIC-&gt;ICout\n\n\nmortality rate(delta)\n\n\n\nconVTC2IC-&gt;IC\n\n\ninfection(beta)\n\n\n\n\n\n\n\n\nこのモデルは Equation 7 の連立微分方程式によって記述される。Equation 5 に標的細胞数\\(T(t)\\)を加えており、非線形項があるので非線形微分方程式と呼ぶ。\n\n\\(T(t)\\): 感染細胞数\n\\(I(t)\\): 感染細胞数\n\\(V(t)\\): ウイルス量\n\\(\\lambda\\): 標的細胞の供給速度\n\\(d\\): 標的細胞の死亡速度\n\\(p\\): ウイルスの生産速度\n\\(\\delta\\): 免疫による感染細胞の排除速度\n\\(\\beta\\): ウイルスの感染率\n\\(c\\): 自然応答によるウイルスの排除速度\n\n\\[\n\\begin{align}\n&\\frac{\\partial T(t)}{\\partial t} = \\lambda - d T(t) - \\beta T(t) V(t) \\\\\n&\\frac{\\partial I(t)}{\\partial t} = \\beta T(t) V(t) - \\delta I(t) \\\\\n&\\frac{\\partial V(t)}{\\partial t} = p I(t) - c V(t)\n\\end{align}\n\\tag{7}\\]\n非線形微分方程式はほぼ一般解を持たないので、これらの動態は逐次近似法によって計算する。計算結果を描画すると細胞・ウイルスについての動態が観察できる。\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: 非線形微分方程式\n\n\n\n\n\n\n\n参考\n\nウイルス感染の数理モデルとシミュレーション\nOverview of Julia’s SciML/Build and run your first simulation with Julia’s SciML\n\n\n\n\n\nReuseCC BY 4.0"
  },
  {
    "objectID": "qmds/posts/20250209_imbalance_evalution/experiment.html",
    "href": "qmds/posts/20250209_imbalance_evalution/experiment.html",
    "title": "不均衡データに対する二値分類評価指標の挙動: 補足資料",
    "section": "",
    "text": "Python言語で書いている\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import stats\nfrom sklearn import metrics\n\n\n実験用コードの準備\n\nclass EvaluateSimulator:\n    def __init__(self, iter: int=100):\n        self.iter = iter\n\n        self.rng: np.ndarray = np.random.default_rng(seed=42)\n        self.scores: dict[str, dict[float, list[float]]] = {}\n\n    def scores_init(self) -&gt; None:\n        self.scores = {\n            \"accuracy\": {},\n            \"ppv\": {},\n            \"npv\": {},\n            \"sensitivity\": {},\n            \"specificity\": {},\n            \"f1-score\": {},\n            \"mcc\": {},\n            \"g-mean\": {},\n            \"roc-auc\": {},\n            \"pr-auc\": {},\n        }\n    \n    def process(self, posi_rates: list[float]) -&gt; None:\n        self.scores_init()\n\n        for posi_rate in posi_rates:\n            for key in self.scores.keys():\n                self.scores[key][posi_rate] = []\n\n            for _ in range(self.iter):\n                y_true, y_pred = self.make_sample(posi_rate)\n                self.scores[\"roc-auc\"][posi_rate].append(self.roc_auc(y_true, y_pred))\n                self.scores[\"pr-auc\"][posi_rate].append(self.pr_auc(y_true, y_pred))\n\n                youden_thr = self.youden_index(y_true, y_pred)\n                cm = self.confusion_matrix(y_true, y_pred, youden_thr)\n\n                self.scores[\"accuracy\"][posi_rate].append(self.accuracy(cm))\n                self.scores[\"ppv\"][posi_rate].append(self.ppv(cm))\n                self.scores[\"npv\"][posi_rate].append(self.npv(cm))\n                self.scores[\"sensitivity\"][posi_rate].append(self.tpr(cm))\n                self.scores[\"specificity\"][posi_rate].append(self.tnr(cm))\n                self.scores[\"f1-score\"][posi_rate].append(self.f1(cm))\n                self.scores[\"mcc\"][posi_rate].append(self.mcc(cm))\n                self.scores[\"g-mean\"][posi_rate].append(self.g_mean(cm))\n\n    def make_sample(\n        self,\n        posi_rate: float,\n        sample_size: int = 10000,\n        alpha: float = 5,\n        beta: float = 3,\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        posi_size = int(sample_size * posi_rate)\n        nega_size = sample_size - posi_size\n\n        y_true = np.concatenate(\n            [np.ones(posi_size), np.zeros(nega_size)],\n            axis=0\n        ).astype(np.int64)\n\n        y_pred = np.concatenate(\n            [\n                self.rng.beta(size=posi_size, a=alpha, b=beta),\n                self.rng.beta(size=nega_size, a=beta, b=alpha),\n            ],\n            axis=0,\n        ).astype(np.float64)\n\n        return y_true, y_pred\n    \n    @staticmethod\n    def roc_auc(y_true: np.ndarray, y_pred: np.ndarray) -&gt; float:\n        return float(metrics.roc_auc_score(y_true, y_pred))\n\n    @staticmethod\n    def pr_auc(y_true: np.ndarray, y_pred: np.ndarray) -&gt; float:\n        precision, recall, _ = metrics.precision_recall_curve(y_true, y_pred)\n        return float(metrics.auc(recall, precision))\n\n    @staticmethod\n    def youden_index(y_true: np.ndarray, y_pred: np.ndarray) -&gt; float:\n        fpr, tpr, thr = metrics.roc_curve(y_true, y_pred)\n        return thr[np.argmax(tpr - fpr)]\n\n    @staticmethod\n    def confusion_matrix(\n        y_true: np.ndarray, y_pred: np.ndarray, thr: float = 0.5\n    ) -&gt; np.ndarray:\n        y_pred = np.where(y_pred &gt; thr, 1, 0)\n        return metrics.confusion_matrix(y_true, y_pred).ravel()\n\n    @staticmethod\n    def accuracy(cm: np.ndarray) -&gt; float:\n        return float((cm[0] + cm[3]) / np.sum(cm))\n\n    @staticmethod\n    def ppv(cm: np.ndarray) -&gt; float:\n        return float(cm[3] / (cm[1] + cm[3]))\n\n    @staticmethod\n    def npv(cm: np.ndarray) -&gt; float:\n        return float(cm[0] / (cm[0] + cm[2]))\n\n    @staticmethod\n    def tpr(cm: np.ndarray) -&gt; float:\n        return float(cm[3] / (cm[2] + cm[3]))\n\n    @staticmethod\n    def tnr(cm: np.ndarray) -&gt; float:\n        return float(cm[0] / (cm[0] + cm[1]))\n\n    @staticmethod\n    def f1(cm: np.ndarray) -&gt; float:\n        return float(2 * cm[3] / (cm[1] + cm[2] + 2 * cm[3]))\n\n    @staticmethod\n    def mcc(cm: np.ndarray) -&gt; float:\n        return float(\n            (\n                (cm[0] * cm[3] - cm[1] * cm[2])\n                 / np.sqrt(\n                     (cm[1] + cm[3])\n                      * (cm[2] + cm[3])\n                      * (cm[0] + cm[2])\n                      * (cm[0] + cm[1])\n                 )\n            )\n        )\n\n    @staticmethod\n    def g_mean(cm: np.ndarray) -&gt; float:\n        return float(\n            np.sqrt(\n                cm[3] / (cm[2] + cm[3]) * cm[0] / (cm[0] + cm[2])\n            )\n        )\n\neval_simulator = EvaluateSimulator()\nposi_rates = [0.5, 0.4, 0.3, 0.2, 0.1, 0.01]\n\n\n\n仮想データの母集団分布\n\nx = np.linspace(0, 1, 101)\n1y_p = stats.beta.pdf(x, 5, 3)\n2y_n = stats.beta.pdf(x, 3, 5)\n\nplt.figure(figsize=(4, 3))\nplt.plot(x, y_p, color=\"red\", label=\"positive\")\nplt.plot(x, y_n, color=\"blue\", label=\"Negative\")\nplt.title(\"Data distribution\")\nplt.xlabel(\"Prediction score\")\nplt.legend(loc='upper left', bbox_to_anchor=(1, 1))\nplt.show()\nplt.close()\n\n\n1\n\n真に陽性群の母集団分布\n\n2\n\n真に陰性群の母集団分布\n\n\n\n\n\n\n\n\n\n\nFigure 1: 仮想データの母集団分布\n\n\n\n\n\n\n\nROC-AUC曲線及びPR-AUC曲線の確認\n\ndef plot_pred(ax: plt.Axes, idx: int, y_true: np.ndarray, y_pred: np.ndarray):\n    ax.set_box_aspect(1)\n    ax.hist(\n        [\n            y_pred[y_true == 1],\n            y_pred[y_true == 0],\n        ],\n        color=[\"red\", \"blue\"],\n        bins=np.linspace(0, 1, 21)\n    )\n    ax.set_xlim([0, 1])\n    ax.set_ylabel(f\"Positive rate: {posi_rate}\")\n    ax.set_xlabel(\"Prediction score\")\n    if idx == 0:\n        ax.set_title(\"Prediction histogram\")\n\ndef plot_roc_auc(ax: plt.Axes, idx: int, y_true: np.ndarray, y_pred: np.ndarray):\n    fpr, tpr, _ = metrics.roc_curve(y_true, y_pred)\n\n    ax.set_box_aspect(1)\n    ax.plot(\n        fpr,\n        tpr,\n        color=\"black\",\n    )\n    ax.set_xlabel(\"FPR\")\n    ax.set_ylabel(\"TPR\")\n    if idx == 0:\n        ax.set_title(\"ROC-AUC curve\")\n\ndef plot_pr_auc(ax: plt.Axes, idx: int, y_true: np.ndarray, y_pred: np.ndarray):\n    precision, recall, _ = metrics.precision_recall_curve(y_true, y_pred)\n\n    ax.set_box_aspect(1)\n    ax.plot(\n        recall,\n        precision,\n        color=\"black\",\n    )\n    ax.set_xlabel(\"Recall\")\n    ax.set_ylabel(\"Precision\")\n    if idx == 0:\n        ax.set_title(\"ROC-AUC curve\")\n\nfig, axes = plt.subplots(\n    6, 3, figsize=(10, 18), sharex=\"col\", sharey=\"col\", tight_layout=True\n)\nfor idx, posi_rate in enumerate(posi_rates):\n    y_true, y_pred = eval_simulator.make_sample(posi_rate)\n    plot_pred(axes[idx][0], idx, y_true, y_pred)\n    plot_roc_auc(axes[idx][1], idx, y_true, y_pred)\n    plot_pr_auc(axes[idx][2], idx, y_true, y_pred)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\nFigure 2: 左から予測値の分布、ROC-AUC曲線、PR-AUC曲線と並べている。真に陽性群の割合は縦で変えており、上から[0.5, 0.4, 0.3, 0.2, 0.1, 0.01]である。分布の赤は真に陽性群、青は真に陰性群を表している。\n\n\n\n\n仮想データによる分布、ROC-AUC曲線、PR-AUC曲線\n\n\n\n反復試行による評価指標の比較\n\neval_simulator.process(posi_rates)\nfig, axes = plt.subplots(5, 2, figsize=(10, 15), tight_layout=True)\n\nfor idx, key in enumerate(eval_simulator.scores.keys()):\n    axes[idx // 2][idx % 2].boxplot(\n        [eval_simulator.scores[key][posi_rate] for posi_rate in posi_rates],\n        tick_labels=posi_rates,\n    )\n    axes[idx // 2][idx % 2].set_title(key)\n    axes[idx // 2][idx % 2].set_xlabel(\"Positive rate\")\n\nplt.show()\nplt.close()\n\n\n\n\n\n\n\nFigure 3: 仮想データによる各評価指標の分布\n\n\n\n\n\n\n\n\n\nReuseCC BY 4.0"
  },
  {
    "objectID": "qmds/contact.html",
    "href": "qmds/contact.html",
    "title": "お問い合わせ",
    "section": "",
    "text": "Google Form\n\n読み込んでいます…\n\n\n\n\n\nReuseCC BY 4.0"
  },
  {
    "objectID": "qmds/posts/20250202_docker_system/index.html",
    "href": "qmds/posts/20250202_docker_system/index.html",
    "title": "QuartoでWebページを作る際のDocker構成について",
    "section": "",
    "text": "概要\n本ブログでは実行環境をDockerで作成している。コードは↓のGithubリンクから参照できる。\n結局、RをQuarto内で認識させることができなかったためローカルで実行するようにした。が、忘備録として残しておく。\n\n\nツール\n\n\n\n\n\n\nWarning\n\n\n\n前もってDocker CLIをインストールしておく。\n※ローカルのターミナル上でdocker、docker composeが動作すれば良い。\n\n\nQuarto websiteを作る上で導入したツールは以下の4つ。\n\nQuarto\n+αでJupyterを動かす場合\n\nR\nPython\nJulia\n\n\nR, Python, Juliaの仮想環境は、公式がサポートしているものを使う。\n\nR: renv\nPython: venv\n\nPoetryを併用して仮想環境を作成する\n\nJulia: Pkg\n\n\n\n\n\n\n\nTip\n\n\n\nデータサイエンス用のプラットフォームであるCondaもQuarto上でサポートされているが、複数の言語を混ぜて使う際に激しめのコンフリクトを起こした。なので、今回はそれぞれの言語専用の仕組みを使用した。\n\n\n\n\nDockerfileの構成\nベースイメージはubuntuを使用する\nFROM ubuntu:latest\n\n\n\n\n\n\nTip\n\n\n\nPythonやRを一気にビルドするベースイメージとして、jupyter/datascience-notebookがある。 実際に試してみたが、Quartoと併用するときに上手く扱えなかった。そこで、まっさらなubuntuイメージから愚直にインストールしていく構成をとった。\n\n\nrenv, pyproject.toml, Project.tomlの構成をDocker内にコピーする。\nCOPY . /web_source/\n\n\n\n\n\n\nCaution\n\n\n\nメモリの節約においては仮想環境用ファイル以外はコピーしなくてよいが、面倒なのでやっていない。今後のTODOとする。\n\n\nubuntu側で必要なツールをインストールする。 同時にRとPython(pip)をインストールする。\nRUN apt update \\\n    && cd /web_source \\\n    && apt install -y --no-install-recommends \\\n        curl \\\n        gdebi \\\n        build-essential \\\n        r-base \\\n        pip \\\n    && rm -rf /var/lib/apt/lists/* \\\nRの仮想環境ビルドのため、renvをインストールする。\n# RUN\n   && Rscript -e 'install.packages(\"renv\", repos=\"https://cloud.r-project.org\")' \\\nPythonの仮想環境ビルドのため、Poetryをインストールする。\n# RUN\n    && pip install poetry --break-system-packages \\\n    && poetry config --local virtualenvs.in-project true \\\nJuliaをインストールする。 加えて、仮想環境を再現する。\n# RUN\n    && curl -fsSL https://install.julialang.org | sh -s -- -y \\\n    && /root/.juliaup/bin/julia --project=@. -e 'using Pkg; Pkg.instantiate(); Pkg.precompile()' \\\n\n\n\n\n\n\nTip\n\n\n\nJuliaダウンロード直後はjuliaコマンドが動かなかった(多分PATHの問題)ため、ファイルから実行している。\n\n\nQuartoをインストールする。\n※インストーラーは最後に削除する。\n# RUN\n    && curl -LO https://quarto.org/download/latest/quarto-linux-amd64.deb \\\n    && gdebi --non-interactive quarto-linux-amd64.deb \\\n    && rm -rf quarto-linux-amd64.deb\nこの構成のDockerfileをbuildすることで、必要な環境が全て入ったDocker containerを作成できる。\n\n\n\n\n\n\nWarning\n\n\n\nPython, Rのパッケージはローカルのものと紐づける設定をしているためbuild時点では環境を再現できていない始めて入った後にpoetry, renvを利用して環境を再現すると良い\n\n\n\n\ndocker-composeの構成\n特別な工夫はしておらず、Dockerに入ったときに作業中のディレクトリ(web_source)とローカルのディレクトリ構成をリンクさせる設定にしている。\nservices:\n  web-source:\n    build: .\n    restart: always\n    ports:\n      - \"8888:8888\"\n    volumes:\n      - ./:/web_source\n    working_dir: /web_source\n    command:\n      # /bin/bash \n      /bin/bash --login\n\n\nJupyterLabでの開発\nDockerを立ち上げる際にportを開放することで、JupyterLabでの開発ができるようにしてある。\ndocker compose run -p 8888:8888 --rm web-source\nこれによって、Docker内で起動したローカルホストが、ローカルPCで開けるようになっている。\n\n\n参考\n\nM2のMacにDockerとDocker Composeをインストールする\n社内のDockerfileのベストプラクティスを公開します\nDocker Composeについてざっくり理解する【概要 / ymlファイル書き方 / コマンド操作】\n\n\n\n\n\nReuseCC BY 4.0"
  },
  {
    "objectID": "qmds/posts/20250209_imbalance_evalution/index.html",
    "href": "qmds/posts/20250209_imbalance_evalution/index.html",
    "title": "不均衡データに対する二値分類評価指標の挙動",
    "section": "",
    "text": "機械学習の二値分類問題において、教師データの陽性・陰性の割合が大きく異なっている不均衡データがよく扱われる。不均衡データは予測を難しくすることは周知の事実だが、加えて様々な評価指標に対してもミスリーディングを生み出すことがある。\nそこで、不均衡データに対する評価指標の挙動を確認していく。"
  },
  {
    "objectID": "qmds/posts/20250209_imbalance_evalution/index.html#混同行列",
    "href": "qmds/posts/20250209_imbalance_evalution/index.html#混同行列",
    "title": "不均衡データに対する二値分類評価指標の挙動",
    "section": "混同行列",
    "text": "混同行列\n二値分類での評価指標の多くは混同行列(Confusion matrix)を用いて算出されている Table 1 。混同行列は教師データのラベルおよび予測モデルによるラベルの二軸で解析集団のクロス集計をとった行列のことである。\n行列の各要素にはそれぞれ定義がされており、教師データに対して予測モデルが正しく予測できたかどうかがカウントされている。\n\nTP: 陽性と予測して、真に陽性だった数\nFP: 陽性と予測して、真は陰性だった数\nFN: 陰性と予測して、真は陽性だった数\nTN: 陰性と予測して、真に陰性だった数\n\n\n\n\nTable 1: 混同行列\n\n\n\n\n\n\n\n\n\n\n\n\nActual\n\n\n(+)\n(-)\n\n\n\n\npredict\n(+)\nTP\nFP\n\n\n(-)\nFN\nTN"
  },
  {
    "objectID": "qmds/posts/20250209_imbalance_evalution/index.html#重要な指標",
    "href": "qmds/posts/20250209_imbalance_evalution/index.html#重要な指標",
    "title": "不均衡データに対する二値分類評価指標の挙動",
    "section": "重要な指標",
    "text": "重要な指標\n二値分類においてよく使われる指標は Table 2 である。一般的にはROC-AUC、F1-scoreをそのモデルの総合的な評価として用いることが多い。\n\n\n\nTable 2: 二値分類の評価指標一覧\n\n\n\n\n\n\n\n\n\n\n\n指標\n記号\n数式\n意味\n\n\n\n\n正答率\nAccuracy\n\\(\\frac{TP + TN}{TP + FP + FN + TN}\\)\n正しく予測できた割合\n\n\n適合率・陽性的中率\nPrecision, PPV\n\\(\\frac{TP}{TP + FP}\\)\n陽性と予測した中で正しく予測できた割合\n\n\n陰性的中率\nNPV\n\\(\\frac{TN}{FN + TN}\\)\n陰性と予測した中で正しく予測できた割合\n\n\n真陽性率・再現率・感度\nRecall, Sensitivity, TPR\n\\(\\frac{TP}{TP + FN}\\)\n真に陽性群の内、正しく予測できた割合\n\n\n真陰性率・特異度\nSpecificity, TNR\n\\(\\frac{TN}{FP + TN}\\)\n真に陰性群の内、正しく予測できた割合\n\n\nF1-score\n\n\\(\\frac{2 TP}{2 TP + FP + FN}\\)\n陽性的中率と感度の調和平均\n\n\nマシューズ相関係数\nMCC\n\\(\\frac{TP \\times TN - FP \\times FN}{\\sqrt{(TP + FP) (TP + FN) (TN + FP) (TN + FN)}}\\)\n不均衡データに対して有効とされている教師データと予測モデル間の相関係数\n\n\nG-mean\n\n\\(\\sqrt{TPR \\times TNR}\\)\n感度と特異度の幾何平均\n\n\nROC-AUC\n\n\nTPR, FPR(偽陽性率)の関係性を曲線にし、その面積をとったもの\n\n\nPR-AUC\n\n\n感度・陽性的中率の関係性を曲線にし、その面積をとったもの"
  },
  {
    "objectID": "qmds/posts/20250209_imbalance_evalution/index.html#仮想データ",
    "href": "qmds/posts/20250209_imbalance_evalution/index.html#仮想データ",
    "title": "不均衡データに対する二値分類評価指標の挙動",
    "section": "仮想データ",
    "text": "仮想データ\n仮想データは乱数生成によって作成したデータを用いる。二値分類の予測値\\(y\\)はロジスティック関数が絡んでいることが多いため、\\(y\\)はベータ分布に従うと仮定する。\n\\[\ny \\sim Beta(\\alpha, \\beta)\n\\]\nベータ分布について、真に陽性群のパラメータを\\((\\alpha, \\beta) = (5, 3)\\)、真に陰性群のパラメータを\\((\\alpha, \\beta) = (3, 5)\\)とする。\n※均衡データに対してROC-AUCが0.85程度になるように調整した。\n\n\n\n\n\n\n\n\n\nFigure 1: 仮想データの母集団分布\n\n\n\n\n\n\nサンプルサイズは10,000で、陽性と陰性の比率については、陽性の割合を\\({ \\{ 0.5, 0.4, 0.3, 0.2, 0.1, 0.01 \\} }\\)の6パターンに分けて実験する。"
  },
  {
    "objectID": "qmds/posts/20250209_imbalance_evalution/index.html#評価",
    "href": "qmds/posts/20250209_imbalance_evalution/index.html#評価",
    "title": "不均衡データに対する二値分類評価指標の挙動",
    "section": "評価",
    "text": "評価\n評価指標 Table 2 の内ROC-AUCとPR-AUC以外は混同行列を基準に算出するため、予測値\\(y\\)を陽性 or 陰性に振り分ける閾値を定義する必要がある。母集団分布上では一律に0.5としても良さそうだが、今回はYouden Indexによって閾値を決める。\n\n\n\n\n\n\nYouden Index\n\n\n\nYouden Indexとは、ROC-AUC曲線上で対角線の間の垂直距離が最大になる閾値のことである。これを用いることで感度・特異度がともに高い閾値を選ぶことができる。\n\\[\n\\max_{threshold} 感度 + 特異度 - 1\n\\]\n\n\nデータ生成→評価指標算出のプロセスを100回行い、それらの振る舞いを評価する。"
  },
  {
    "objectID": "qmds/posts/20250209_imbalance_evalution/index.html#roc-auc曲線pr-auc曲線の変化",
    "href": "qmds/posts/20250209_imbalance_evalution/index.html#roc-auc曲線pr-auc曲線の変化",
    "title": "不均衡データに対する二値分類評価指標の挙動",
    "section": "ROC-AUC曲線、PR-AUC曲線の変化",
    "text": "ROC-AUC曲線、PR-AUC曲線の変化\nまずは、1回の試行での仮想データを使ってROC-AUC曲線およびPR-AUC曲線を確認した。これを見ると、ROC-AUC曲線は不均衡具合が強くなっても大きく指標が変化しない。一方で、PR-AUC曲線は不均衡具合が強くなると曲線も大きく歪むことが見てとれる。\nこのことから、以下のことが言える。 - ROC-AUC曲線は教師データのバランスには言及せずに、あくまで予測モデルが正しく推論できたかを重視している - PR-AUC曲線は不均衡データになると、予測値の分布が同じでも精度が落ちる\n\n\n\n\n\n\n\n\n\nFigure 2: 左から予測値の分布、ROC-AUC曲線、PR-AUC曲線と並べている。真に陽性群の割合は縦で変えており、上から[0.5, 0.4, 0.3, 0.2, 0.1, 0.01]である。分布の赤は真に陽性群、青は真に陰性群を表している。\n\n\n\n\n仮想データによる分布、ROC-AUC曲線、PR-AUC曲線"
  },
  {
    "objectID": "qmds/posts/20250209_imbalance_evalution/index.html#反復試行での各評価指標の比較",
    "href": "qmds/posts/20250209_imbalance_evalution/index.html#反復試行での各評価指標の比較",
    "title": "不均衡データに対する二値分類評価指標の挙動",
    "section": "反復試行での各評価指標の比較",
    "text": "反復試行での各評価指標の比較\n各評価指標を仮想データから算出し、その分布を比較する。大きく分けると以下の3つの挙動が見える\n\n中央値はそこまで変わらないが、分散が大きくなる\n\nAccuracy, Sensitivity, Specificity, ROC-AUC\n\n精度が著しく悪化する\n\nPPV, F1-score, MCC, PR-AUC\n\n精度が著しく良化する\n\nNPV, G-mean\n\n\nPPV, NPVについては、真に陰性群の割合を下げていくと↑の関係が逆転すると思われる。G-meanに関しては感度、特異度の分散が上昇したことによってその積の値が大きくなりやすくなった影響だと思われる。\n\n\n\n\n\n\n\n\n\nFigure 3: 仮想データによる各評価指標の分布\n\n\n\n\n\n\n不均衡データによって、全ての評価指標に変化があることが確認できた。特に、値が変わらないものも分散が大きくなっていることが分かった。"
  },
  {
    "objectID": "qmds/posts/draft_virus_simulation_2/simulation.html",
    "href": "qmds/posts/draft_virus_simulation_2/simulation.html",
    "title": "ウイルス感染症の数理シミュレーション（応用）: 補足資料",
    "section": "",
    "text": "Julia言語で書いている\nusing DifferentialEquations\nusing ModelingToolkit\nusing Plots"
  },
  {
    "objectID": "qmds/posts/draft_virus_simulation_2/simulation.html#解離接着までのモデル",
    "href": "qmds/posts/draft_virus_simulation_2/simulation.html#解離接着までのモデル",
    "title": "ウイルス感染症の数理シミュレーション（応用）: 補足資料",
    "section": "解離・接着までのモデル",
    "text": "解離・接着までのモデル\n\nlet\n1    @independent_variables t\n    @variables V_dis(t)=1.0 V_att(t)=150.0\n2    @parameters k_dis=3.4 k_att=0.16\n    \n3    D = Differential(t)\n    eqs = [\n        D(V_dis) ~ k_dis * V_att - k_att * V_dis\n        D(V_att) ~ k_att * V_dis - k_dis * V_att\n    ]\n    @mtkbuild sys = ODESystem(eqs, t)\n    \n4    tspan = (0.0, 30.0)\n5    prob = ODEProblem(sys, [], tspan)\n    sol = solve(prob)\n    \n    dinamics_plot = plot(\n        sol[t],\n        [sol[V_dis], sol[V_att]],\n        title=\"Virus dinamics\",\n        xlabel=\"Hour\",\n        ylabel=\"Virus\",\n        label=[\"dissociate\" \"attach\"],\n        color=[:blue :orange],\n    )\n        \n    plot(\n        dinamics_plot,\n        size=(600, 300),\n        left_margin = 20Plots.px,\n        bottom_margin = 20Plots.px,\n        legend=:outertopright,\n    )\nend\n\n\n1\n\n初期値の設定\n\n2\n\nパラメータの設定\n\n3\n\n微分方程式の定義\n\n4\n\n時間軸の設定\n\n5\n\n微分方程式の逐次計算\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 解離・接着についての数理モデリング"
  },
  {
    "objectID": "qmds/posts/draft_virus_simulation_2/simulation.html#全状態を考慮したモデル",
    "href": "qmds/posts/draft_virus_simulation_2/simulation.html#全状態を考慮したモデル",
    "title": "ウイルス感染症の数理シミュレーション（応用）: 補足資料",
    "section": "全状態を考慮したモデル",
    "text": "全状態を考慮したモデル\n\nfunction virus_dinamics(\n    v::Dict{String, Float64},\n    p::Dict{String, Float64},\n    t_end::Float64=70.0 / 24.0,\n)\n1    @independent_variables t\n    @variables V_dis(t)=v[\"V_dis\"]\n    @variables V_att(t)=v[\"V_att\"]\n    @variables V_int(t)=v[\"V_int\"]\n    @variables V_ccc(t)=v[\"V_ccc\"]\n2    @parameters k_dis=p[\"k_dis\"]\n    @parameters k_att=p[\"k_att\"]\n    @parameters k_int=p[\"k_int\"]\n    @parameters k_ccc=p[\"k_ccc\"]\n    @parameters k_di=p[\"k_di\"]\n    @parameters k_dc=p[\"k_dc\"]\n    @parameters K=p[\"K\"]\n    \n3    D = Differential(t)\n    eqs = [\n        D(V_dis) ~ k_dis * V_att - k_att * V_dis\n        D(V_att) ~ k_att * V_dis - k_dis * V_att - k_int * V_att\n        D(V_int) ~ k_int * V_att - k_ccc * (1 - V_ccc / K) * V_int - k_di * V_int\n        D(V_ccc) ~ k_ccc * (1 - V_ccc / K) * V_int - k_dc * V_ccc\n    ]\n    @mtkbuild sys = ODESystem(eqs, t)\n    \n4    tspan = (0.0, t_end)\n5    prob = ODEProblem(sys, [], tspan)\n    return solve(prob)\nend\n\n\n1\n\n初期値の設定\n\n2\n\nパラメータの設定\n\n3\n\n微分方程式の定義\n\n4\n\n時間軸の設定\n\n5\n\n微分方程式の逐次計算\n\n\n\n\nvirus_dinamics (generic function with 2 methods)\n\n\n\nlet\n    v::Dict{String, Float64} = Dict(\n        \"V_dis\" =&gt; 1.0,\n        \"V_att\" =&gt; 150.0,\n        \"V_int\" =&gt; 1.0,\n        \"V_ccc\" =&gt; 1.0,\n    )\n    p::Dict{String, Float64} = Dict(\n        \"k_dis\" =&gt; 3.4,\n        \"k_att\" =&gt; 0.16,\n        \"k_int\" =&gt; 3.0,\n        \"k_ccc\" =&gt; 0.65,\n        \"k_di\" =&gt; 1.9,\n        \"k_dc\" =&gt; 0.12,\n        \"K\" =&gt; 3.7,\n    )\n    sol = virus_dinamics(v, p)\n    u = reduce(hcat, sol.u)\n    \n    dinamics_plot = plot(\n        sol.t,\n        [u[1, :] u[2, :] u[3, :] u[4, :]],\n        title=\"Virus dinamics\",\n        xlabel=\"Day\",\n        ylabel=\"Virus\",\n        label=[\"dissociate\" \"attach\" \"internalization\" \"cccDNA\"],\n        color=[:blue :orange :red :firebrick],\n    )\n    cccDNA_plot = plot(\n        sol.t,\n        u[4, :],\n        title=\"cccDNA dinamics\",\n        xlabel=\"Day\",\n        ylabel=\"cccDNA\",\n        label=\"cccDNA\",\n        color=:firebrick,\n    )\n        \n    plot(\n        dinamics_plot,\n        cccDNA_plot,\n        size=(900, 300),\n        left_margin = 20Plots.px,\n        bottom_margin = 20Plots.px,\n    )\nend\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: 解離・接着についての数理モデリング\n\n\n\n\n\nlet\n    v::Dict{String, Float64} = Dict(\n        \"V_dis\" =&gt; 1.0,\n        \"V_att\" =&gt; 150.0,\n        \"V_int\" =&gt; 1.0,\n        \"V_ccc\" =&gt; 1.0,\n    )\n    p::Dict{String, Float64} = Dict(\n        \"k_dis\" =&gt; 3.4,\n        \"k_att\" =&gt; 0.16,\n        \"k_int\" =&gt; 3.0,\n        \"k_ccc\" =&gt; 0.65,\n        \"k_di\" =&gt; 1.9,\n        \"k_dc\" =&gt; 0.12,\n        \"K\" =&gt; 3.7,\n    )\n    \n    inhibition_rate = Vector(0:0.01:1)\n    \n    u_att::Vector{Float64} = Vector()\n    u_int::Vector{Float64} = Vector()\n    u_ccc::Vector{Float64} = Vector()\n    \n    for alpha = inhibition_rate\n        p[\"k_att\"] = (1 - alpha) * 0.16\n        sol = virus_dinamics(v, p, 12.0)\n        u = reduce(hcat, sol.u)\n        push!(u_att, u[4, end])\n    end\n    p[\"k_att\"] = 0.16\n    \n    for alpha = inhibition_rate\n        p[\"k_int\"] = (1 - alpha) * 3.0\n        sol = virus_dinamics(v, p, 12.0)\n        u = reduce(hcat, sol.u)\n        push!(u_int, u[4, end])\n    end\n    p[\"k_int\"] = 3.0\n    \n    for alpha = inhibition_rate\n        p[\"k_ccc\"] = (1 - alpha) * 0.65\n        sol = virus_dinamics(v, p, 12.0)\n        u = reduce(hcat, sol.u)\n        push!(u_ccc, u[4, end])\n    end\n    p[\"k_ccc\"] = 0.65\n    \n    cccDNA_plot = plot(\n        inhibition_rate,\n        [u_att u_int u_ccc],\n        title=\"Inhibition rate effect\",\n        xlabel=\"Inhibition rate\",\n        ylabel=\"cccDNA (after 12 days)\",\n        label=[\"attach\" \"internalization\" \"cccDNA\"],\n    )\n        \n    plot(\n        cccDNA_plot,\n        size=(600, 300),\n        left_margin = 20Plots.px,\n        bottom_margin = 20Plots.px,\n        legend=:outertopright,\n    )\nend\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: 活性阻害の効果"
  },
  {
    "objectID": "qmds/posts/20250209_virus_simulation_1/simulation.html",
    "href": "qmds/posts/20250209_virus_simulation_1/simulation.html",
    "title": "ウイルス感染症の数理シミュレーション（基礎）: 補足資料",
    "section": "",
    "text": "Julia言語で書いている\n\nusing DifferentialEquations\nusing ModelingToolkit\nusing Plots\n\n\n指数方程式\n\nlet\n1    t::Vector{Float64} = Vector(0:0.001:3)\n    \n2    G::Float64 = 1.5\n    Vi_0::Float64 = 2.0 * 10^3\n    Vi_t::Vector{Float64} = Vi_0 * exp.(G * t)\n    t_D::Float64 = log(2) / G\n    \n    inc_plot = plot(\n        t,\n        Vi_t,\n        label=\"V(t)\",\n        color=\"red\",\n        title=\"Increase virus\",\n        xlabel=\"Day\",\n        ylabel=\"Virus\",\n    )\n    vline!(\n        inc_plot,\n        [t_D],\n        color=\"black\",\n        linestyle=:dash,\n        label=\"tD\",\n    )\n    \n3    D::Float64 = 1.5\n    Vd_0::Float64 = 2.0 * 10^3\n    Vd_t::Vector{Float64} = Vd_0 * exp.(-D * t)\n    t_H::Float64 = log(2) / D\n    \n    dec_plot = plot(\n        t,\n        Vd_t,\n        label=\"V(t)\",\n        color=:blue,\n        title=\"Decrease virus\",\n        xlabel=\"Day\",\n        ylabel=\"Virus\",\n    )\n    vline!(\n        dec_plot,\n        [t_H],\n        color=:black,\n        linestyle=:dash,\n        label=\"tH\",\n    )\n    \n    plot(\n        inc_plot,\n        dec_plot,\n        size=(800, 300),\n        left_margin = 20Plots.px,\n        bottom_margin = 20Plots.px,\n    )\nend\n\n\n1\n\n時刻の定義\n\n2\n\n増加指数方程式の記述\n\n3\n\n減少指数方程式の記述\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: 指数方程式\n\n\n\n\n\n\nロジスティック方程式\n\nlet\n1    t::Vector{Float64} = Vector(0:0.0001:0.5)\n    \n2    function logit_eq(\n        t::Vector{Float64},\n        V_0::Float64;\n        G::Float64=50.0,\n        K_v::Float64=5.0 * 10^6,\n    )\n        return (\n            (V_0 * K_v * exp.(G * t))\n            ./ (K_v .- V_0 .+ V_0 * exp.(G * t))\n        )\n    end\n    \n    logit_plot = plot(\n        t,\n        [\n            logit_eq(t, 1.0 * 10^7),\n            logit_eq(t, 2.5 * 10^6),\n            logit_eq(t, 1.0),\n        ],\n        title=\"Logistics equation\",\n        xlabel=\"Day\",\n        ylabel=\"Virus\",\n        label=[\n            \"V(0): 1.0 * 10^7\" \"V(0): 2.5 * 10^6\" \"V(0): 1.0\"\n        ],\n        ylim=(0, 1.0 * 10 ^ 7),\n    )\n    \n    plot(\n        logit_plot,\n        size=(400, 400),\n        left_margin = 20Plots.px,\n        bottom_margin = 20Plots.px,\n    )\nend\n\n\n1\n\n時刻の定義\n\n2\n\nロジスティック方程式の定義\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: ロジスティック方程式: K_V=5.0 * 10^6\n\n\n\n\n\n\n線形微分方程式\n\nlet\n1    t::Vector{Float64} = Vector(0:0.001:10)\n    \n2    function liner_simultaneous_eq(\n        t::Vector{Float64},\n        beta::Float64,\n        delta::Float64,\n        p::Float64,\n        c::Float64;\n        T_0::Float64=3.7 * 10^5,\n        I_0::Float64=1.0,\n        V_0::Float64=100.0,\n    )\n        theta_1 = (-(delta + c) + sqrt((delta - c)^2 + 4 * beta * p * T_0)) / 2\n        theta_2 = (-(delta + c) - sqrt((delta - c)^2 + 4 * beta * p * T_0)) / 2\n        I_t = (\n            ((beta * T_0 * V_0) - (delta + theta_2) * I_0) / (theta_1 - theta_2)\n            * (exp.(theta_1 * t) - exp.(theta_2 * t))\n        ) + I_0 * exp.(theta_2 * t)\n        V_t = (\n            ((p * I_0) - (c + theta_2) * I_0) / (theta_1 - theta_2)\n            * (exp.(theta_1 * t) - exp.(theta_2 * t))\n        ) + V_0 * exp.(theta_2 * t)\n        return I_t, V_t\n    end\n    \n    I_t, V_t = liner_simultaneous_eq(t, 1.0 * 10^-7, 1.0, 1.0 * 10^3, 10.0)\n    liner_plot = plot(\n        t,\n        [I_t, V_t],\n        title=\"Logistics equation\",\n        xlabel=\"Day\",\n        yscale=:log10,\n        label=[\"infected cell (R0 &gt; 1)\" \"virus (R0 &gt; 1)\"],\n        color=:red,\n        linestyle=[:solid :dash],\n    )\n    I_t, V_t = liner_simultaneous_eq(t, 1.0 * 10^-13, 1.0, 1.0 * 10^3, 10.0)\n    plot!(\n        liner_plot,\n        t,\n        [I_t, V_t],\n        title=\"Logistics equation\",\n        xlabel=\"Day\",\n        yscale=:log10,\n        label=[\"infected cell (R0 &lt; 1)\" \"virus (R0 &lt; 1)\"],\n        color=:blue,\n        linestyle=[:solid :dash],\n    )\n    \n    plot(\n        liner_plot,\n        size=(600, 400),\n        left_margin = 20Plots.px,\n        bottom_margin = 20Plots.px,\n        legend=:outertopright,\n    )\nend\n\n\n1\n\n時刻の定義\n\n2\n\n線形微方程式の定義\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: 線形微分方程式\n\n\n\n\n\n\n非線形微分方程式\n\nlet\n1    @variables t T(t)=6.4*10^6 I(t)=0.1 V(t)=5.0*10^4\n2    @parameters λ=0.0 d=0.05 β=8.6*10^-11 δ=1.75+0.05 p=3.0*10^4 c=1.93\n\n3    D = Differential(t)\n    eqs = [\n        D(T) ~ λ - d * T - β * T * V\n        D(I) ~ β * T * V - δ * I\n        D(V) ~ p * I - c * V\n    ]\n    @mtkbuild sys = ODESystem(eqs, t)\n\n4    tspan = (0.0, 25.0)\n5    prob = ODEProblem(sys, [], tspan)\n    sol = solve(prob)\n\n    cell_plot = plot(\n        sol[t],\n        [sol[T], sol[I]],\n        title=\"Cell dinamics\",\n        xlabel=\"Day\",\n        ylabel=\"Cell\",\n        yscale=:log10,\n        label=[\"target\" \"infected\"],\n        color=[:blue :red],\n    )\n    virus_plot = plot(\n        sol[t],\n        sol[V],\n        title=\"Virus dinamics\",\n        xlabel=\"Day\",\n        ylabel=\"Virus\",\n        label=\"Virus\",\n        yscale=:log10,\n        color=:black,\n    )\n    \n    plot(\n        cell_plot,\n        virus_plot,\n        size=(800, 400),\n        left_margin = 20Plots.px,\n        bottom_margin = 20Plots.px,\n    )\nend\n\n\n1\n\n初期値の設定\n\n2\n\nパラメータの設定\n\n3\n\n微分方程式の定義\n\n4\n\n時間軸の設定\n\n5\n\n微分方程式の逐次計算\n\n\n\n\n┌ Warning: Independent variable t should be defined with @independent_variables t.\n└ @ ModelingToolkit /Users/yuheiyasui/.julia/packages/ModelingToolkit/K8zNC/src/utils.jl:119\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: 非線形微分方程式\n\n\n\n\n\n\n\n\nReuseCC BY 4.0"
  },
  {
    "objectID": "qmds/about.html",
    "href": "qmds/about.html",
    "title": "管理者について",
    "section": "",
    "text": "生物統計学と遺伝統計学を頑張りたい人。R&D寄りのデータサイエンティスト。\n\n経歴\n\n熊本県で生まれ育つ\n国立大学の数学科を卒業\n\n解析学(微分積分学)を中心に数学理論を学ぶ\n\n国立大学院の生命科学専攻を修了\n\nWetな手法でエピジェネティクスと初期発生に関する研究を行う\n定量化の方法としては画像解析系の技術を学ぶ\n\n受託分析会社でデータサイエンティストとして勤務\n\nデータ利活用を目的としたコンサルテーションを担当\nBIエンジニアリング, AIエンジニアリング, データ基盤作成, データ分析業を幅広く学ぶ\nプロジェクトリーダーを経験\n\n医療系ベンチャー企業のAIエンジニアとして勤務 ← Now\n\n医療機器に組み込む疾患予測モデルの構築\n社内データ基盤の整備\n臨床研究におけるデータ解析を担当\n\n\n\n\n\nReuseCC BY 4.0"
  }
]